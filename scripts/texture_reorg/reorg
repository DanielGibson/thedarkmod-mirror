#!/usr/bin/python

import os
import string
import sys
import re
import glob
import scriptutil

#from DebugMessage import stdMsg, dbgMsg, errMsg, setDebugging


LOGFILE="reorg_logfile.txt"
#SrcPath="/cygdrive/d/Home/cygwin/gruberg/darkmod"
#DstPath="/cygdrive/d/Home/cygwin/gruberg/darkmod_reorg"
SrcPath="/home/sparhawk/darkmod"
DstPath="/home/sparhawk/darkmod_reorg"

total_material_names = {}

class Texture:
	def __init__(self):
		self.TextureName = ""
		self.TextureExt = ""
		self.TextureMaterial = ""
		self.TexturePath = ""

	def __repr__(self):
		return "['"+self.TexturePath+"', '" +self.TextureName + "', '" + self.TextureExt + "', " + self.TextureMaterial +"']"

class TextureRecord:
	def __init__(self):
		self.mNew = Texture()
		self.mOld = Texture()
		self.MaterialFilename = []

	def __repr__(self):
		mat = ""
		if self.MaterialFilename == None:
			mat = "None"
		else:
			for i in self.MaterialFilename:
				mat += "'"+i+"', "

			mat = mat[0:len(mat)-2]

		return "[* "+mat + "\n **" + self.mOld.__repr__() + "\n **" + self.mNew.__repr__()+" *]\n"

class TextureReorg:
	def __init__(self, Logfile, SrcPath, DstPath, InputFile):
		self.mLogFile = self.OpenFile(Logfile, "w+b")
		self.mInput = self.OpenFile(InputFile, "r+b")
		self.mSrcPath = SrcPath
		self.mDstPath = DstPath
		self.mMaterial = glob.glob(SrcPath+"/materials/*")
		self.mMaterialFile = {}
		self.mMaterialFileFlag = {}
		self.mTextureRecord = []
		try:
			os.mkdir(DstPath + "/textures")
		except OSError:
			pass
		try:
			os.mkdir(DstPath + "/dds")
		except OSError:
			pass
		try:
			os.mkdir(DstPath + "/dds/textures")
		except OSError:
			pass
		try:
			os.mkdir(DstPath + "/materials")
		except OSError:
			pass

	def OpenFile(self, name, mode):
		try:
			fl = file(name, mode)
		except IOError:
			print "Couldn't open "+name
			sys.exit(1)
		return fl

	def ParseInput(self):
		bSVN = 0
		bDir = 0
		dir = []
		path = ""
		while 1:
			ln = self.mInput.readline()

			if not ln:
				break

			ln = ln.strip()
			if(len(ln) == 0):
				continue

			if(len(ln.split("Volume")) > 1):
				continue

			if(len(ln.split("File(s)")) > 1):
				continue

			if(len(ln.split("Total Files Listed:")) > 1):
				continue

			if(len(ln.split("Dir(s)")) > 1):
				continue

			if(len(ln.split("<DIR>")) > 1):
				continue

			# We need to get all directory names ...
			t = ln.split("Directory of")
			if(len(t) > 1):
				bSVN = 0
				bDir = 1

			# ... but only if it's not part of SVN
			if(len(ln.split(".svn")) > 1):
				bSVN = 1

			if(bSVN == 1):
				continue

			if(bDir == 1):
				bDir = 0
				if(len(dir) != 0):
					self.mTextureRecord.append(dir)

				path = (t[1].strip().replace("\\", "/").split("D:/temp2/")[1]).strip()
				try:
					os.mkdir(DstPath + "/" + path)
					os.mkdir(DstPath + "/dds/" + path)
				except OSError:
					pass
				#print path
				dir = []
				continue

			t = ln[39:]
			v = t.split(".")
			record = TextureRecord()
			record.mNew.TexturePath = path
			if(len(v) == 2):
				#print "Texture has only one name:"+t
				record.mNew.TextureName = v[0].strip()
				record.mNew.TextureExt = v[1].strip()
				record.mOld.TextureName = v[0].strip()
				record.mOld.TextureExt = v[1].strip()
			elif(len(v) == 4):
				record.mOld.TextureName = v[2].strip()
				record.mOld.TextureExt = v[3].strip()
				record.mNew.TextureName = v[0].strip()
				record.mNew.TextureExt = v[1].strip()
			else:
				print "Wrong number of arguments: "+ln

			dir.append(record)
			if(self.TextureMaterial(record.mOld.TextureName, record.MaterialFilename) == None):
				record.MaterialFilename = []
				print "No material: ["+ path +"] "+record.mOld.TextureName, t

		self.mInput.close()

	def SearchTexture(self, path, texname):
		rc = None

		flist = scriptutil.ffind(path, namefs=(lambda s: '.svn' not in s, lambda s: texname in s,))
		#print len(flist), flist, path, texname

		if len(flist) == 1:
			rc = flist[0]
		elif len(flist) > 1:
			print "File ["+texname+"] in more then one directory!", flist

		return rc

	def Exists(self, matarray, matname):
		b = 0;

		for i in matarray:
			if(matname == i):
				#print matname + " Exists", matarray
				b = 1
				break

		return b

	def TextureMaterial(self, tname, matarray):
		rc = None
		for fn in self.mMaterial:
			t = fn.split("replacements.txt")
			if(len(t) > 1):
				continue

			t = fn.split("gildoran_notes.txt")
			if(len(t) > 1):
				continue

			b = ""
			try:
				t = self.mMaterialFile[fn]
				b = t[0]
			except KeyError:
				f = open(fn)
				b = f.read()
				f.close()
				t = []
				t.append(b)
				l = b.split("\n")
				ind = 0
				prevind = 0
				n = len(l)
				i = 0
				title = 'l'

				# Now we construct the indentation level
				# so we can easily identify the material
				# names afterwards.
				while i < n:
					m = l[i]
					m0 = m.split("\r")
					if(len(m0) > 1):
						m = m0[0]

					s = m.strip()
					if s[0:1] == "{":
						ind = ind + 1
					elif s[0:1] == "}":
						ind = ind - 1

					# Check if we have found a material name
					if ind == 1 and prevind == 0:
						total_material_names[l[i-1][0]] = 0
						l[i-1][2] = 'n'

					prevind = ind
					l[i] =  [m, ind, 'l']
					i = i+1

				t.append(l)
				self.mMaterialFile[fn] = t
				self.mMaterialFileFlag[fn] = 0

			t = b.split(tname)
			if(len(t) > 1):
				if(self.Exists(matarray, fn) == 0):
					fn = fn.split(SrcPath+"/")[1]
					matarray.append(fn)
					rc = 1
					#print fn

		return rc

	def ReplaceTexture(self, mat, oname, nname, record):
		rc = 0

		if oname == nname:
			return rc

		tname = None
		mn = len(mat[1])
		mi = 0
		mat_title = 0
		while mi < mn:
			l = mat[1][mi]
			if l[1] == 0:
				tname = None

			if l[2] == 'n':
				tname = l[0]
				if(len(tname.strip()) == 0):
					sys.exit(0)
				mat_title = mi
				mi = mi + 1
				continue

			# Check if the texture is contained in that
			# material line and if it is the real name.
			# We have to check for the real name because
			# otherwise partial names would also match
			# which causes wrong entries.
			t = l[0].split(oname)
			if(len(t) > 1):
				if(len(t[1]) == 0 or t[1][0] == '.'):
					sl = "textures/"
					p = t[0].split(sl)
					if(len(p) == 1):
						p = t[0].split("textures\\")

					if(len(p) == 1):
						sl = "models/"
						p = t[0].split(sl)

					if(len(p) == 1):
						p = t[0].split("models\\")

					p = p[1]
					p = p[0:len(p)-1].replace("\\", "/")
					record.mOld.TexturePath = sl+p
					# Update the line in the material with the new texturepath
					mat[1][mi][0] = t[0] + nname + t[1]
					#print "[*"+mat[1][mat_title][0]+"*]"
					total_material_names[mat[1][mat_title][0]] = total_material_names[mat[1][mat_title][0]] + 1
					rc = 1
			mi = mi + 1

		return rc

	def DumpMaterial(self, name):
		#print "Material: "+name
		matfile = self.mMaterialFile[SrcPath+"/"+name]

		if(self.mMaterialFileFlag[SrcPath+"/"+name] == 0):
			return

		fl = self.OpenFile(DstPath+"/"+name, "w+b")
		for i in matfile[1]:
			fl.write(i[0]+"\n")
		fl.close()
		#sys.exit(0)
		return

	def ProcessReorg(self):
		for dir in self.mTextureRecord:
			for record in dir:
				for matname in record.MaterialFilename:
					#print matname
					self.mMaterialFileFlag[SrcPath+"/"+matname] = self.ReplaceTexture(self.mMaterialFile[SrcPath+"/"+matname], record.mOld.TextureName, record.mNew.TextureName, record)
					if self.mMaterialFileFlag[SrcPath+"/"+matname] == 1:
						print matname + ":"+ record.mOld.TexturePath+"/"+record.mOld.TextureName + ":" + record.mNew.TexturePath+"/"+record.mNew.TextureName

		for dir in self.mTextureRecord:
			for record in dir:
				for matname in record.MaterialFilename:
					self.DumpMaterial(matname)
		return

	def CreateUnusedTextureMaterials(self):
		fl = self.OpenFile(DstPath+"/materials/"+"unknown.mtr", "w+b")
		fl.write("# This file was automatically created by sparhawk for the texture reorganization\n")
		fl.write("# materials here should be reviewed and then copied to the appropriate file.\n\n\n")
		for dir in self.mTextureRecord:
			for record in dir:
				if(len(record.MaterialFilename) == 0):
					fl.write(record.mNew.TexturePath+"/"+record.mNew.TextureName+"\n")
					fl.write("{\n")
					fl.write("    diffusemap  "+record.mNew.TexturePath+"/"+record.mNew.TextureName+"\n")
					fl.write("    {\n")
					fl.write("        if ( parm11 > 0 )\n")
					fl.write("        blend       gl_dst_color, gl_one\n")
					fl.write("        map         _white.tga\n")
					fl.write("        rgb         0.40 * parm11\n")
					fl.write("    }\n")
					fl.write("    {\n")
					fl.write("        if ( parm11 > 0 )\n")
					fl.write("        blend       add\n")
					fl.write("        map         "+record.mNew.TexturePath+"/"+record.mNew.TextureName+"\n")
					fl.write("        rgb         0.15 * parm11\n")
					fl.write("    }\n")
					fl.write("}\n\n\n")

		fl.close()
		return

	def SearchTexturePath(self, tname):
		rc = None

		path = scriptutil.ffind(SrcPath+"/textures", namefs=(lambda s: '.svn' not in s, lambda s: tname in s,))
		if(len(path) == 0):
			path = scriptutil.ffind(SrcPath+"/dds/textures", namefs=(lambda s: '.svn' not in s, lambda s: tname in s,))

		if(len(path) == 0):
			print "No texturefile found: "+tname
		elif(len(path) > 1):
			print "Multiple textures found: ", path
		else:
			rc = path

		return rc

	def CopyTextures(self):
		for dir in self.mTextureRecord:
			for record in dir:
				sname = SrcPath+"/"+record.mOld.TexturePath+"/"+record.mOld.TextureName+"."+record.mOld.TextureExt
				if(len(record.mOld.TexturePath) == 0):
					if(self.SearchTexturePath(record.mOld.TextureName) == None):
						print "No valid path for: "+record.mOld.TextureName
						continue

				tname = DstPath+"/"+record.mNew.TexturePath+"/"+record.mNew.TextureName+"."+record.mNew.TextureExt

				b = None
				try:
					sfl = file(sname, "r+b")
					b = sfl.read()
				except IOError:
					try:
						sname = SrcPath+"/dds/"+record.mOld.TexturePath+"/"+record.mOld.TextureName+"."+record.mOld.TextureExt
						tname = DstPath+"/dds/"+record.mNew.TexturePath+"/"+record.mNew.TextureName+"."+record.mNew.TextureExt
						sfl = file(sname, "r+b")
						b = sfl.read()
					except IOError:
						path = self.SearchTexturePath(record.mOld.TextureName)
						if(path == None):
							print "path lookup failed, giving up: ", record.mOld.TextureName
							continue

						try:
							sname = path[0]
							sfl = file(sname, "r+b")
							b = sfl.read()
						except IOError:
							print "Couldn't open target: "+sname
							continue

				try:
					tfl = file(tname, "w+b")
					tfl.write(b)
				except IOError:
					print "Couldn't open target: "+tname
					sfl.close()
					continue

				sfl.close()
				tfl.close()

				print "Copy: " + sname + " -> " + tname
		return

if __name__ == '__main__':
	#setDebugging(1)
	#print scriptutil.ffind(SrcPath+"/textures", namefs=(lambda s: '.svn' not in s, lambda s: 'test_volumetric' in s,))

	if len(sys.argv) <= 1:
		print "USAGE: reorg Inputfile"
		sys.exit(1)

	reorg = TextureReorg(LOGFILE, SrcPath, DstPath, sys.argv[1])
	reorg.ParseInput()
	reorg.ProcessReorg()
	reorg.CreateUnusedTextureMaterials()
	reorg.CopyTextures()
	n = 0
	for i in total_material_names:
		if(total_material_names[i] != 0):
			print i, total_material_names[i]
			n = n + 1
	print n
	#print total_material_names, len(total_material_names)
	sys.exit(0)
